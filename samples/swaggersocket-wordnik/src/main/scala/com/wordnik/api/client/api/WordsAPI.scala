/**
 *  Copyright 2012 Wordnik, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.wordnik.api.client.api

import com.wordnik.api.client.model._

import org.codehaus.jackson.map.DeserializationConfig.Feature
import org.codehaus.jackson.map.ObjectMapper
import org.codehaus.jackson.`type`.TypeReference
import com.wordnik.swagger.runtime.annotations._
import com.wordnik.swagger.runtime.common._
import com.wordnik.swagger.runtime.exception._

import java.io.IOException

import scala.collection.mutable._
import scala.collection.JavaConversions._


/**
 *
 * NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
 * @author tony
 *
 */
object WordsAPI {

    /**
     * Searches words.
     *
     * 
     * 
     * @param query  Search term
 @param caseSensitive  Search case sensitive
     *      Allowed values are - true,false  @param includePartOfSpeech  Only include these comma-delimited parts of speech
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param excludePartOfSpeech  Exclude these comma-delimited parts of speech
 @param minCorpusCount  Minimum corpus frequency for terms
     *      Allowed values are - range[0.0,Infinity]  @param maxCorpusCount  Maximum corpus frequency for terms
     *      Allowed values are - range[0.0,Infinity]  @param minDictionaryCount  Minimum number of dictionary entries for words returned
     *      Allowed values are - range[0.0,Infinity]  @param maxDictionaryCount  Maximum dictionary definition count
     *      Allowed values are - range[0.0,Infinity]  @param minLength  Minimum word length
     *      Allowed values are - range[0.0,1024.0]  @param maxLength  Maximum word length
     *      Allowed values are - range[0.0,1024.0]  @param skip  Results to skip
     *      Allowed values are - range[0.0,1000.0]  @param limit  Maximum number of results to return
     *      Allowed values are - range[1.0,1000.0]  
     * @return List[WordFrequency] {@link WordFrequency} 
     * @throws APIException 400 - Invalid term supplied. 404 - No results. 
     */
     @MethodArgumentNames(value="query, caseSensitive, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, skip, limit") 
     @throws(classOf[APIException])
     def searchWords(query:String, caseSensitive:String, includePartOfSpeech:String, excludePartOfSpeech:String, minCorpusCount:String, maxCorpusCount:String, minDictionaryCount:String, maxDictionaryCount:String, minLength:String, maxLength:String, skip:String, limit:String) :List[WordFrequency] = {

        //parse inputs
        var resourcePath = "/words.{format}/search".replace("{format}","json")
        val method = "GET";
        var queryParams = new HashMap[String, String]
        var headerParams = new HashMap[String, String]

        if(null != query) {
             queryParams += "query" -> APIInvoker.toPathValue(query)
        }
        if(null != caseSensitive) {
             queryParams += "caseSensitive" -> APIInvoker.toPathValue(caseSensitive)
        }
        if(null != includePartOfSpeech) {
             queryParams += "includePartOfSpeech" -> APIInvoker.toPathValue(includePartOfSpeech)
        }
        if(null != excludePartOfSpeech) {
             queryParams += "excludePartOfSpeech" -> APIInvoker.toPathValue(excludePartOfSpeech)
        }
        if(null != minCorpusCount) {
             queryParams += "minCorpusCount" -> APIInvoker.toPathValue(minCorpusCount)
        }
        if(null != maxCorpusCount) {
             queryParams += "maxCorpusCount" -> APIInvoker.toPathValue(maxCorpusCount)
        }
        if(null != minDictionaryCount) {
             queryParams += "minDictionaryCount" -> APIInvoker.toPathValue(minDictionaryCount)
        }
        if(null != maxDictionaryCount) {
             queryParams += "maxDictionaryCount" -> APIInvoker.toPathValue(maxDictionaryCount)
        }
        if(null != minLength) {
             queryParams += "minLength" -> APIInvoker.toPathValue(minLength)
        }
        if(null != maxLength) {
             queryParams += "maxLength" -> APIInvoker.toPathValue(maxLength)
        }
        if(null != skip) {
             queryParams += "skip" -> APIInvoker.toPathValue(skip)
        }
        if(null != limit) {
             queryParams += "limit" -> APIInvoker.toPathValue(limit)
        }

        
    
        //make the API Call
        val response = APIInvoker.getApiInvoker.invokeAPI(resourcePath, method, queryParams, null, headerParams)
        if(null == response || response.length() == 0){
            null
        }        
        val typeRef = new TypeReference[Array[WordFrequency]] {}
        try {
            val responseObject = APIInvoker.mapper.readValue(response, typeRef).asInstanceOf[Array[WordFrequency]]
            responseObject.toList
        } catch { 
        	case ioe:IOException => {
	            val args = Array(response, typeRef.toString())
	            throw new APIException(APIExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe)
	        }
	        case _ => throw new APIException(APIExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, "Error in converting response json value to java object")
        }                        
     }
    /**
     * Returns a specific WordOfTheDay
     *
     * 
     * 
     * @param date  Fetches by date in yyyy-MM-dd
 @param category  Filters response by category
 @param creator  Filters response by username
 
     * @return WordOfTheDay {@link WordOfTheDay} 
     * @throws APIException 
     */
     @MethodArgumentNames(value="date, category, creator") 
     @throws(classOf[APIException])
     def getWordOfTheDay(date:String, category:String, creator:String) :WordOfTheDay = {

        //parse inputs
        var resourcePath = "/words.{format}/wordOfTheDay".replace("{format}","json")
        val method = "GET";
        var queryParams = new HashMap[String, String]
        var headerParams = new HashMap[String, String]

        if(null != date) {
             queryParams += "date" -> APIInvoker.toPathValue(date)
        }
        if(null != category) {
             queryParams += "category" -> APIInvoker.toPathValue(category)
        }
        if(null != creator) {
             queryParams += "creator" -> APIInvoker.toPathValue(creator)
        }

        
    
        //make the API Call
        val response = APIInvoker.getApiInvoker.invokeAPI(resourcePath, method, queryParams, null, headerParams)
        if(null == response || response.length() == 0){
            null
        }        //create output objects if the response has more than one object
        val responseObject = APIInvoker.deserialize(response, classOf[WordOfTheDay]).asInstanceOf[WordOfTheDay]
        responseObject        
                
     }
    /**
     * Searches words.
     *
     * 
     * 
     * @param query  Search query
 @param caseSensitive  Search case sensitive
     *      Allowed values are - true,false  @param includePartOfSpeech  Only include these comma-delimited parts of speech
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param excludePartOfSpeech  Exclude these comma-delimited parts of speech
 @param minCorpusCount  Minimum corpus frequency for terms
     *      Allowed values are - range[0.0,Infinity]  @param maxCorpusCount  Maximum corpus frequency for terms
     *      Allowed values are - range[0.0,Infinity]  @param minDictionaryCount  Minimum number of dictionary entries
     *      Allowed values are - range[0.0,Infinity]  @param maxDictionaryCount  Maximum dictionary count
     *      Allowed values are - range[0.0,Infinity]  @param minLength  Minimum word length
     *      Allowed values are - range[0.0,1024.0]  @param maxLength  Maximum word length
     *      Allowed values are - range[0.0,1024.0]  @param skip  Results to skip
     *      Allowed values are - range[0.0,1000.0]  @param limit  Maximum number of results to return
     *      Allowed values are - range[1.0,1000.0]  
     * @return WordSearchResults {@link WordSearchResults} 
     * @throws APIException 400 - Invalid query supplied. 
     */
     @MethodArgumentNames(value="query, caseSensitive, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, skip, limit") 
     @throws(classOf[APIException])
     def searchWordsNew(query:String, caseSensitive:String, includePartOfSpeech:String, excludePartOfSpeech:String, minCorpusCount:String, maxCorpusCount:String, minDictionaryCount:String, maxDictionaryCount:String, minLength:String, maxLength:String, skip:String, limit:String) :WordSearchResults = {

        //parse inputs
        var resourcePath = "/words.{format}/search/{query}".replace("{format}","json")
        val method = "GET";
        var queryParams = new HashMap[String, String]
        var headerParams = new HashMap[String, String]

        if(null != caseSensitive) {
             queryParams += "caseSensitive" -> APIInvoker.toPathValue(caseSensitive)
        }
        if(null != includePartOfSpeech) {
             queryParams += "includePartOfSpeech" -> APIInvoker.toPathValue(includePartOfSpeech)
        }
        if(null != excludePartOfSpeech) {
             queryParams += "excludePartOfSpeech" -> APIInvoker.toPathValue(excludePartOfSpeech)
        }
        if(null != minCorpusCount) {
             queryParams += "minCorpusCount" -> APIInvoker.toPathValue(minCorpusCount)
        }
        if(null != maxCorpusCount) {
             queryParams += "maxCorpusCount" -> APIInvoker.toPathValue(maxCorpusCount)
        }
        if(null != minDictionaryCount) {
             queryParams += "minDictionaryCount" -> APIInvoker.toPathValue(minDictionaryCount)
        }
        if(null != maxDictionaryCount) {
             queryParams += "maxDictionaryCount" -> APIInvoker.toPathValue(maxDictionaryCount)
        }
        if(null != minLength) {
             queryParams += "minLength" -> APIInvoker.toPathValue(minLength)
        }
        if(null != maxLength) {
             queryParams += "maxLength" -> APIInvoker.toPathValue(maxLength)
        }
        if(null != skip) {
             queryParams += "skip" -> APIInvoker.toPathValue(skip)
        }
        if(null != limit) {
             queryParams += "limit" -> APIInvoker.toPathValue(limit)
        }

        if(null != query) {
            resourcePath = resourcePath.replace("{query}", APIInvoker.toPathValue(query))
        }
        
    
        //make the API Call
        val response = APIInvoker.getApiInvoker.invokeAPI(resourcePath, method, queryParams, null, headerParams)
        if(null == response || response.length() == 0){
            null
        }        //create output objects if the response has more than one object
        val responseObject = APIInvoker.deserialize(response, classOf[WordSearchResults]).asInstanceOf[WordSearchResults]
        responseObject        
                
     }
    /**
     * Returns an array of random WordObjects
     *
     * 
     * 
     * @param hasDictionaryDef  Only return words with dictionary definitions
     *      Allowed values are - false,true  @param includePartOfSpeech  CSV part-of-speech values to include
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param excludePartOfSpeech  CSV part-of-speech values to exclude
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param minCorpusCount  Minimum corpus frequency for terms (integer)
 @param maxCorpusCount  Maximum corpus frequency for terms (integer)
 @param minDictionaryCount  Minimum dictionary count (integer)
 @param maxDictionaryCount  Maximum dictionary count (integer)
 @param minLength  Minimum word length (characters)
 @param maxLength  Maximum word length (characters)
 @param sortBy  Attribute to sort by
     *      Allowed values are - alpha,count  @param sortOrder  Sort direction
     *      Allowed values are - asc,desc  @param limit  Maximum number of results to return
 
     * @return List[WordObject] {@link WordObject} 
     * @throws APIException 400 - Invalid term supplied. 404 - No results. 
     */
     @MethodArgumentNames(value="hasDictionaryDef, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, sortBy, sortOrder, limit") 
     @throws(classOf[APIException])
     def getRandomWords(hasDictionaryDef:String, includePartOfSpeech:String, excludePartOfSpeech:String, minCorpusCount:String, maxCorpusCount:String, minDictionaryCount:String, maxDictionaryCount:String, minLength:String, maxLength:String, sortBy:String, sortOrder:String, limit:String) :List[WordObject] = {

        //parse inputs
        var resourcePath = "/words.{format}/randomWords".replace("{format}","json")
        val method = "GET";
        var queryParams = new HashMap[String, String]
        var headerParams = new HashMap[String, String]

        if(null != hasDictionaryDef) {
             queryParams += "hasDictionaryDef" -> APIInvoker.toPathValue(hasDictionaryDef)
        }
        if(null != includePartOfSpeech) {
             queryParams += "includePartOfSpeech" -> APIInvoker.toPathValue(includePartOfSpeech)
        }
        if(null != excludePartOfSpeech) {
             queryParams += "excludePartOfSpeech" -> APIInvoker.toPathValue(excludePartOfSpeech)
        }
        if(null != minCorpusCount) {
             queryParams += "minCorpusCount" -> APIInvoker.toPathValue(minCorpusCount)
        }
        if(null != maxCorpusCount) {
             queryParams += "maxCorpusCount" -> APIInvoker.toPathValue(maxCorpusCount)
        }
        if(null != minDictionaryCount) {
             queryParams += "minDictionaryCount" -> APIInvoker.toPathValue(minDictionaryCount)
        }
        if(null != maxDictionaryCount) {
             queryParams += "maxDictionaryCount" -> APIInvoker.toPathValue(maxDictionaryCount)
        }
        if(null != minLength) {
             queryParams += "minLength" -> APIInvoker.toPathValue(minLength)
        }
        if(null != maxLength) {
             queryParams += "maxLength" -> APIInvoker.toPathValue(maxLength)
        }
        if(null != sortBy) {
             queryParams += "sortBy" -> APIInvoker.toPathValue(sortBy)
        }
        if(null != sortOrder) {
             queryParams += "sortOrder" -> APIInvoker.toPathValue(sortOrder)
        }
        if(null != limit) {
             queryParams += "limit" -> APIInvoker.toPathValue(limit)
        }

        
    
        //make the API Call
        val response = APIInvoker.getApiInvoker.invokeAPI(resourcePath, method, queryParams, null, headerParams)
        if(null == response || response.length() == 0){
            null
        }        
        val typeRef = new TypeReference[Array[WordObject]] {}
        try {
            val responseObject = APIInvoker.mapper.readValue(response, typeRef).asInstanceOf[Array[WordObject]]
            responseObject.toList
        } catch { 
        	case ioe:IOException => {
	            val args = Array(response, typeRef.toString())
	            throw new APIException(APIExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe)
	        }
	        case _ => throw new APIException(APIExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, "Error in converting response json value to java object")
        }                        
     }
    /**
     * Returns a single random WordObject
     *
     * 
     * 
     * @param hasDictionaryDef  Only return words with dictionary definitions
     *      Allowed values are - false,true  @param includePartOfSpeech  CSV part-of-speech values to include
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param excludePartOfSpeech  CSV part-of-speech values to exclude
     *      Allowed values are - noun,adjective,verb,adverb,interjection,pronoun,preposition,abbreviation,affix,article,auxiliary-verb,conjunction,definite-article,family-name,given-name,idiom,imperative,noun-plural,noun-posessive,past-participle,phrasal-prefix,proper-noun,proper-noun-plural,proper-noun-posessive,suffix,verb-intransitive,verb-transitive  @param minCorpusCount  Minimum corpus frequency for terms
 @param maxCorpusCount  Maximum corpus frequency for terms
 @param minDictionaryCount  Minimum dictionary count
 @param maxDictionaryCount  Maximum dictionary count
 @param minLength  Minimum word length
 @param maxLength  Maximum word length
 
     * @return WordObject {@link WordObject} 
     * @throws APIException 404 - No word found. 
     */
     @MethodArgumentNames(value="hasDictionaryDef, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength") 
     @throws(classOf[APIException])
     def getRandomWord(hasDictionaryDef:String, includePartOfSpeech:String, excludePartOfSpeech:String, minCorpusCount:String, maxCorpusCount:String, minDictionaryCount:String, maxDictionaryCount:String, minLength:String, maxLength:String) :WordObject = {

        //parse inputs
        var resourcePath = "/words.{format}/randomWord".replace("{format}","json")
        val method = "GET";
        var queryParams = new HashMap[String, String]
        var headerParams = new HashMap[String, String]

        if(null != hasDictionaryDef) {
             queryParams += "hasDictionaryDef" -> APIInvoker.toPathValue(hasDictionaryDef)
        }
        if(null != includePartOfSpeech) {
             queryParams += "includePartOfSpeech" -> APIInvoker.toPathValue(includePartOfSpeech)
        }
        if(null != excludePartOfSpeech) {
             queryParams += "excludePartOfSpeech" -> APIInvoker.toPathValue(excludePartOfSpeech)
        }
        if(null != minCorpusCount) {
             queryParams += "minCorpusCount" -> APIInvoker.toPathValue(minCorpusCount)
        }
        if(null != maxCorpusCount) {
             queryParams += "maxCorpusCount" -> APIInvoker.toPathValue(maxCorpusCount)
        }
        if(null != minDictionaryCount) {
             queryParams += "minDictionaryCount" -> APIInvoker.toPathValue(minDictionaryCount)
        }
        if(null != maxDictionaryCount) {
             queryParams += "maxDictionaryCount" -> APIInvoker.toPathValue(maxDictionaryCount)
        }
        if(null != minLength) {
             queryParams += "minLength" -> APIInvoker.toPathValue(minLength)
        }
        if(null != maxLength) {
             queryParams += "maxLength" -> APIInvoker.toPathValue(maxLength)
        }

        
    
        //make the API Call
        val response = APIInvoker.getApiInvoker.invokeAPI(resourcePath, method, queryParams, null, headerParams)
        if(null == response || response.length() == 0){
            null
        }        //create output objects if the response has more than one object
        val responseObject = APIInvoker.deserialize(response, classOf[WordObject]).asInstanceOf[WordObject]
        responseObject        
                
     }

}